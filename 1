# Prac1 Practical 1.a Generate Adjacency List

from collections import defaultdict

n = int(input("Enter Number of Vertices: "))
e = int(input("Enter Number of Edges: "))

graph = defaultdict(list)

for i in range(e):
    u1,u2 = input().split()
    graph[u1].append(u2)
    if u1!=u2:
        graph[u2].append(u1)
        
for i in graph:        
    print(i,graph[i])

# Practical 1.b Generate adjacency matrix

from collections import defaultdict
def createGraph():
    v = int(input("Enter Number for vertices: "))
    e = int(input("Enter Number for edges: "))
    graph = defaultdict(list)
    for i in range (e):
        u1,u2 = input().split()
        graph[u1].append(u2)
        if u1!=u2:
            graph[u2].append(u1)
    for i in graph:
        print(i,graph[i])
    return graph
    graph = createGraph()




def verticesDict(graph):
    vertices_list = list(graph.keys())
    vertices_dict ={}
    for i in range(len(vertices_list)):
        vertices_dict[vertices_list[i]]=i
    return vertices_dict
 
def adjacencyMatrix(graph,vertices_dict):
    adjacency_matrix = [[0]*len(list(graph.keys()))
                       for i in range(len(list(graph.keys())))]
    for key in graph:
        i = vertices_dict[key]
        for edge in graph[key]:
            if i == vertices_dict[edge]:
                adjacency_matrix[i][vertices_dict[edge]]=2
            else:
                adjacency_matrix[i][vertices_dict[edge]]=1
    print("\nAdjacency Matrix:")
    for i in adjacency_matrix:
        print(*i)  
graph = createGraph() 
adjacencyMatrix(graph,verticesDict(graph))  


# Practical 1.c Generate Adjacency Matrix for Weighted Graphs

def printmatrix(matrix):
    r,c=len(matrix),len(matrix[0])
    for i in range(r):
        for j in range(c):
            print(matrix[i][j],end="")
        print()
v,e=map(int,input().split())
matrix=[[0]*v for i in range(v)]
for i in range(e):
    u,v=map(str,input().split())
    w=int(input())
    u=ord(u)-ord('a')  #ord: calculates the ascii value of the character
    v=ord(v)-ord('a')
    matrix[u][v]=w
printmatrix(matrix)        


def print_matrix(matrix):
    for row in matrix:
        print(*row)

v, e = map(int, input().split())
matrix = [[0] * v for _ in range(v)]

for _ in range(e):
    u, v, w = input().split()
    u, v = ord(u) - ord('a'), ord(v) - ord('a')
    matrix[u][v] = int(w)

print_matrix(matrix)

\
# pRac2 minimum spanning tree 
# Prim's algorithm for finding the minimum spanning tree in a graph

INF = 9999999

def primMST(V, G):
    selected = [False] * V
    selected[0] = True
    no_edge = 0

    print("Edge : Weight\n")

    while no_edge < V - 1:
        minimum = INF
        x = 0
        y = 0
        for i in range(V):
            if selected[i]:
                for j in range(V):
                    if not selected[j] and G[i][j] and minimum > G[i][j]:
                        minimum = G[i][j]
                        x = i
                        y = j

        print(f"{x} - {y} : {G[x][y]}")
        selected[y] = True
        no_edge += 1

if __name__ == '__main__':
    V = int(input("Enter the number of vertices: "))

    G = []
    print("Enter the adjacency matrix:")
    for _ in range(V):
        row = list(map(int, input().split()))
        G.append(row)

    primMST(V, G)


# Python program for Kruskal's algorithm to find Minimum Spanning Tree

# Class to represent a graph 
class Graph: 
  
    def __init__(self, vertices): 
        self.V = vertices 
        self.graph = [] 
  
    # Function to add an edge to graph 
    def addEdge(self, u, v, w): 
        self.graph.append([u, v, w]) 
  
    # A utility function to find set of an element i 
    # (truly uses path compression technique) 
    def find(self, parent, i): 
        if parent[i] != i: 
  
            # Reassignment of node's parent 
            # to root node as 
            # path compression requires 
            parent[i] = self.find(parent, parent[i]) 
        return parent[i] 
  
    # A function that does union of two sets of x and y 
    # (uses union by rank) 
    def union(self, parent, rank, x, y): 
  
        # Attach smaller rank tree under root of 
        # high rank tree (Union by Rank) 
        if rank[x] < rank[y]: 
            parent[x] = y 
        elif rank[x] > rank[y]: 
            parent[y] = x 
  
        # If ranks are same, then make one as root 
        # and increment its rank by one 
        else: 
            parent[y] = x 
            rank[x] += 1
  
    # The main function to construct MST 
    # using Kruskal's algorithm 
    def KruskalMST(self): 
  
        # This will store the resultant MST 
        result = [] 
  
        # An index variable, used for sorted edges 
        i = 0
  
        # An index variable, used for result[] 
        e = 0
  
        # Sort all the edges in 
        # non-decreasing order of their 
        # weight 
        self.graph = sorted(self.graph, 
                            key=lambda item: item[2]) 
  
        parent = [] 
        rank = [] 
  
        # Create V subsets with single elements 
        for node in range(self.V): 
            parent.append(node) 
            rank.append(0) 
  
        # Number of edges to be taken is less than to V-1 
        while e < self.V - 1: 
  
            # Pick the smallest edge and increment 
            # the index for next iteration 
            u, v, w = self.graph[i] 
            i = i + 1
            x = self.find(parent, u) 
            y = self.find(parent, v) 
  
            # If including this edge doesn't 
            # cause cycle, then include it in result 
            # and increment the index of result 
            # for next edge 
            if x != y: 
                e = e + 1
                result.append([u, v, w]) 
                self.union(parent, rank, x, y) 
            # Else discard the edge 
  
        minimumCost = 0
        print("Edges in the constructed MST") 
        for u, v, weight in result: 
            minimumCost += weight 
            print("%d -- %d == %d" % (u, v, weight)) 
        print("Minimum Spanning Tree", minimumCost) 
  
  
# Driver code 
if __name__ == '__main__': 
    g = Graph(4) 
    g.addEdge(0, 1, 10) 
    g.addEdge(0, 2, 6) 
    g.addEdge(0, 3, 5) 
    g.addEdge(1, 3, 15) 
    g.addEdge(2, 3, 4) 
  
    # Function call 
    g.KruskalMST()


class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = []

    def addEdge(self, u, v, w):
        self.graph.append((u, v, w))

    def KruskalMST(self):
        result = []
        self.graph.sort(key=lambda item: item[2])
        parent = list(range(self.V))

        def find(i):
            if parent[i] != i:
                parent[i] = find(parent[i])
            return parent[i]

        def union(x, y):
            parent[find(x)] = find(y)

        e = 0
        i = 0
        while e < self.V - 1:
            u, v, w = self.graph[i]
            i += 1
            x, y = find(u), find(v)
            if x != y:
                e += 1
                result.append((u, v, w))
                union(x, y)

        minimumCost = sum(weight for _, _, weight in result)
        print("Edges in the constructed MST")
        for u, v, weight in result:
            print(f"{u} -- {v} == {weight}")
        print("Minimum Spanning Tree", minimumCost)

# Driver code
if __name__ == '__main__':
    num_vertices = int(input("Enter the number of vertices: "))
    g = Graph(num_vertices)

    while True:
        try:
            u, v, w = map(int, input("Enter edge (u v w), or type 'done' to finish: ").split())
            g.addEdge(u, v, w)
        except ValueError:
            break

    # Function call
    g.KruskalMST()
    
    """Enter the number of vertices: 6
Enter edge (u v w), or type 'done' to finish: 5 3 20
Enter edge (u v w), or type 'done' to finish: 4 5 55
Enter edge (u v w), or type 'done' to finish: 2 5 15
Enter edge (u v w), or type 'done' to finish: 2 4 35
Enter edge (u v w), or type 'done' to finish: 0 1 10
Enter edge (u v w), or type 'done' to finish: 0 3 30
Enter edge (u v w), or type 'done' to finish: 0 4 45
Enter edge (u v w), or type 'done' to finish: 1 2 50
Enter edge (u v w), or type 'done' to finish: 1 3 25
Enter edge (u v w), or type 'done' to finish: 1 4 40
Enter edge (u v w), or type 'done' to finish: done
Edges in the constructed MST
0 -- 1 == 10
2 -- 5 == 15
5 -- 3 == 20
1 -- 3 == 25
2 -- 4 == 35
Minimum Spanning Tree 105"""



# 3A Dijkstra's Algorithm

import heapq
from collections import defaultdict

def shortestPath(graph, src, dest):
    h = []
    heapq.heappush(h, (0, src))
    while len(h) != 0:
        currcost, curvtx = heapq.heappop(h)
        if curvtx == dest:
            print("Path exists from {} to {} with cost {}.".format(src, dest, currcost))
            break
        for neigh, neighcost in graph[curvtx]:
            heapq.heappush(h, (currcost + neighcost, neigh))

graph = defaultdict(list)
v, e = map(int, input("Enter no of vertices and edges:").split())
for i in range(e):
    u, v, w = map(str, input("Enter edges and weights:").split())
    graph[u].append((v, int(w)))

src, dest = map(str, input("Enter source and destination:").split())
shortestPath(graph, src, dest)


# 3B  Floyd-Warshall Algorithm
INF = float('inf')

def printmatrix(m):
    r, c = len(m), len(m[0])
    for i in range(r):
        for j in range(c):
            print(m[i][j], end="\t")
        print()

v, e = map(int, input("Enter number of Vertices and Edges: ").split())
m = [[None] * v for i in range(v)]

for i in range(v):
    for j in range(v):
        # src=dst
        if i == j:
            m[i][j] = 0
        # edge does not exist
        else:
            m[i][j] = INF

# take input values
for i in range(e):
    src, dst, wt = map(int, input("Enter edges and the weights: ").split())
    m[src-1][dst-1] = wt

print("Original Matrix:")
printmatrix(m)
print("........................................")

# apply your algo
# T.C=(v^3)
for k in range(v):
    for i in range(v):
        for j in range(v):
            # cost of tmp path is less
            # update
            if m[i][k] + m[k][j] < m[i][j]:
                m[i][j] = m[i][k] + m[k][j]

print("Final Matrix:")
printmatrix(m)

# Python3 program to print DFS traversal from a given  graph
from collections import defaultdict
 
 
# This class represents a directed graph using
# adjacency list representation
class Graph:
 
    # Constructor
    def __init__(self):
 
        # Default dictionary to store graph
        self.graph = defaultdict(list)
 
     
    # Function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)
 
     
    # A function used by DFS
    def DFSUtil(self, v, visited):
 
        # Mark the current node as visited
        # and print it
        visited.add(v)
        print(v, end=' ')
 
        # Recur for all the vertices
        # adjacent to this vertex
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)
 
     
    # The function to do DFS traversal. It uses
    # recursive DFSUtil()
    def DFS(self, v):
 
        # Create a set to store visited vertices
        visited = set()
 
        # Call the recursive helper function
        # to print DFS traversal
        self.DFSUtil(v, visited)
 
 
# Driver's code
if __name__ == "__main__":
    g = Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)
 
    print("Following is Depth First Traversal (starting from vertex 2)")
     
    # Function call
    g.DFS(2)


# Python3 Program to print BFS traversal from a given source vertex. BFS(int s) traverses vertices reachable from s.



from collections import defaultdict
 
 
# This class represents a directed graph
# using adjacency list representation
class Graph:
 
    # Constructor
    def __init__(self):
 
        # Default dictionary to store graph
        self.graph = defaultdict(list)
 
    # Function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)
 
    # Function to print a BFS of graph
    def BFS(self, s):
 
        # Mark all the vertices as not visited
        visited = [False] * (max(self.graph) + 1)
 
        # Create a queue for BFS
        queue = []
 
        # Mark the source node as
        # visited and enqueue it
        queue.append(s)
        visited[s] = True
 
        while queue:
 
            # Dequeue a vertex from
            # queue and print it
            s = queue.pop(0)
            print(s, end=" ")
 
            # Get all adjacent vertices of the
            # dequeued vertex s.
            # If an adjacent has not been visited,
            # then mark it visited and enqueue it
            for i in self.graph[s]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True
 
 
# Driver code
if __name__ == '__main__':
 
    # Create a graph given in
    # the above diagram
    g = Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)
 
    print("Following is Breadth First Traversal"
          " (starting from vertex 2)")
    g.BFS(2)


# prac 5 Random Graph
import networkx as nx
import matplotlib.pyplot as plt
import random

#distribution graph from Erdos_renyl model

def distribution_graph(g):
    print(nx.degree(g))
    all_node_degree=list(dict((nx.degree(g))).values())
   
    unique_degree=list(set(all_node_degree))
    unique_degree.sort()
    nodes_with_degree=[]
    for i in unique_degree:
        nodes_with_degree.append(all_node_degree.count(i))
    plt.plot(unique_degree,nodes_with_degree)
    plt.xlabel("Degrees")
    plt.ylabel("Number of nodes")
    plt.title("Degree distribution")
    plt.show()
   
#take N number of nodes from user
print("Enter number of nodes: ")
N=int(input())

#take P probability for every edges
print("Enter value of probability of every node: ")
P=float(input())

#create an empty graph object
g=nx.Graph()
#part of network module,vreating an empty graph using it

#adding nodes
g.add_nodes_from(range(1,N+1))
#1,2,3 as 4 is not considered

#add edge to the graph randomly
for i in g.nodes():
    for j in g.nodes():
        if (i<j):
            #take random number R:
            R=random.random()
            #creates some random value that will be 0-1 by default
            #check if R<P add the edge to the graph else ignore
            if (R<P):
                #random value which will be 0-1 and we are taking 0 for example
                g.add_edge(i,j)
    #for printing the nodes
    pos=nx.circular_layout(g)
    #display the social netwrok
    nx.draw(g,pos,with_labels=1)
    plt.show()

#display connection between nodes
distribution_graph(g)


# 6A. Generate Random Walk

import random
import numpy as np
import matplotlib.pyplot as plt
def random_walk(steps):
    position=0
    positions=[position]
    for _ in range(steps):
        step = random.choice([-1,1])
        position+=step
        positions.append(position)
    return positions

steps=1000
walk=random_walk(steps)

plt.plot(range(steps+1),walk)
plt.xlabel('Steps')
plt.ylabel('Positions')
plt.show()

# 6B. Check Behaviour Of Random Walk
def random_walk(steps):
    position=0
    positions=[position]
    for _ in range(steps):
        step = random.choice([-1,1])
        position+=step
        positions.append(position)
    return positions

def analyze_random_walk(steps, trails):
    mean_displacements= []
    variances= []
    for _ in range(trails):
        walk=random_walk(steps)
        mean_displacement = np.mean(walk)
        variance=np.var(walk)
        mean_displacements.append(mean_displacement)
        variances.append(variance)
    return mean_displacements, variances

steps=1000
trails=1000

mean_displacements, variances= analyze_random_walk(steps, trails)
plt.figure(figsize=(10,5))

plt.subplot(1,2,1)
plt.hist(mean_displacements, bins=30, edgecolor="black")
plt.xlabel("Mean Displacement")
plt.ylabel("Frequency")
plt.title("Distribution of Mean Displacement")

plt.subplot(1,2,2)
plt.hist(variances,bins=30, edgecolor="black")
plt.xlabel("Variance")
plt.ylabel("Frequency")
plt.title("Distribution of Variance")

plt.tight_layout()
plt.show()

# 6C. Find Stationery Probability Of Random Walk

import random
import numpy as np
import matplotlib.pyplot as plt

def random_walk(steps):
    position = 0
    positions = [position]
    for _ in range(steps):
        step = random.choice([-1, 1])
        position += step
        positions.append(position)
    return positions

def stationary_distribution(steps, trials):
    counts = np.zeros(2 * steps + 1)
    for _ in range(trials):
        walk = random_walk(steps)
        for position in walk:
            counts[position + steps] += 1
    probs = counts / (trials * (2 * steps + 1))
    return probs

steps = 1000
trials = 10000
probs = stationary_distribution(steps, trials)

plt.plot(range(-steps, steps + 1), probs)
plt.xlabel('position')
plt.ylabel('probability')
plt.title('stationary probability distribution of random walks')
plt.show()


# Prac 7 svd Image Compression
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.image import imread 
import numpy.linalg as nplinalg

a = imread('fds.jpg') 
x = np.mean(a, -1)

img = plt.imshow(x, cmap='gray')
plt.axis("off")
plt.show()


import numpy as np
import matplotlib.pyplot as plt

# Assume x is your input image as a NumPy array

# Perform SVD
u, s, vt = np.linalg.svd(x)

# List of values of r for compression
r_values = [5, 30, 500]

# Loop through r values
for r in r_values:
    # Truncate SVD components
    u_trunc = u[:, :r]
    s_trunc = np.diag(s[:r])
    vt_trunc = vt[:r, :]
    
    # Reconstruct compressed image
    x_approx = u_trunc @ s_trunc @ vt_trunc
    
   
    
    # Display the compressed image
    plt.imshow(x_approx, cmap='gray')
    plt.axis('off')
    plt.title(f'r={r}')
    plt.show()


import numpy as np
import matplotlib.pyplot as plt

# Assume 'a' is your input image as a NumPy array

# Take the mean along the last axis to convert to grayscale
X = np.mean(a,-1)

# Display the image with a blue colormap
plt.imshow(X, cmap='Reds')
plt.axis('off')
plt.show()


# prac8 pca
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
%matplotlib inline

from sklearn import datasets
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

from sklearn.datasets import load_breast_cancer

# Load the breast cancer dataset
cancer = load_breast_cancer()
cancer.keys()

df = pd.DataFrame(cancer['data'],columns=cancer['feature_names'])
df.head()

scaler=StandardScaler()
scaler.fit(df)
scaled_data = scaler.transform(df)
scaled_data
pca = PCA(n_components=2)
pca.fit(scaled_data)
scaled_data.shape
x_pca = pca.transform(scaled_data)
x_pca.shape
x_pca

# Plot PCA
y=cancer.target
plt.figure(figsize=(8, 6))
for i, target_name in enumerate(cancer.target_names):
    plt.scatter(x_pca[y == i, 0], x_pca[y == i, 1], label=target_name)
    plt.xlabel('Principal Component 1')
    plt.ylabel('Principal Component 2')
    plt.title('PCA of Breast Cancer dataset')
    plt.legend()
    plt.show()
